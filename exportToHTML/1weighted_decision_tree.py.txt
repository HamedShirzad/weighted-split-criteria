weighted_decision_tree.py

1    import numpy as np
2    #from custom_tree_classifier.models.decision_tree import CustomDecisionTreeClassifier
3    from custom_tree_classifier.metrics.metric_base import MetricBase
4    # Ø§Ø² Ø¢Ù†Ø¬Ø§ÛŒÛŒ Ú©Ù‡ Ø¯ÛŒÚ¯Ø± Ø§Ø² Ø§ÛŒÙ† Ú©Ù„Ø§Ø³ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù†Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…ØŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ø¢Ù† Ø±Ø§ Ø­Ø°Ù Ú©Ø±Ø¯ ÛŒØ§ Ú©Ø§Ù…Ù†Øª Ú©Ø±Ø¯
5    # from utils.voting_split_manager import FNWeightedSplitManager
6    
7    # Import Ù…Ø¹ÛŒØ§Ø±Ù‡Ø§ (Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ±)
8    #from criteria.gini import gini_criterion
9    from criteria.qg import gain_ratio_criterion
10   from criteria.twoing import twoing_criterion
11   from criteria.ng import normalized_gain_criterion
12   from criteria.mch import multi_class_hellinger
13   from criteria.marsh import marsh_criterion
14   from criteria.gs import g_statistic_criterion
15   from criteria.dkm import dkm_criterion
16   from criteria.cs import chi_squared_criterion
17   from criteria.bhy import bhattacharyya_criterion
18   from criteria.ks import kolmogorov_smirnov_criterion
19   
20   # ================================================================
21   # Ú©Ù„Ø§Ø³ Û±: SingleCriterionMetric (Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ± Ùˆ Ø¶Ø±ÙˆØ±ÛŒ)
22   # Ø§ÛŒÙ† Ú©Ù„Ø§Ø³ Ø¨Ø±Ø§ÛŒ ØªØ³Øª Ø§ÛŒØ²ÙˆÙ„Ù‡ Ù‡Ø± Ù…Ø¹ÛŒØ§Ø± Ø¯Ø± ÙØ±Ø¢ÛŒÙ†Ø¯ Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙˆØ²Ù† Ù„Ø§Ø²Ù… Ø§Ø³Øª.
23   # ================================================================
24   class SingleCriterionMetric(MetricBase):
25       """ 
26       ÛŒÚ© Ú©Ù„Ø§Ø³ Ú©Ù…Ú©ÛŒ Ø¨Ø±Ø§ÛŒ Ø¨Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ ÛŒÚ© Ù…Ø¹ÛŒØ§Ø± Ù…Ù†ÙØ±Ø¯ Ø¯Ø± Ù‚Ø§Ù„Ø¨ÛŒ Ú©Ù‡ 
27       Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ CustomDecisionTreeClassifier Ø¢Ù† Ø±Ø§ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ù…ØªØ±ÛŒÚ© Ù…ÛŒâ€ŒÙ¾Ø°ÛŒØ±Ø¯. 
28       Ø§ÛŒÙ† Ú©Ù„Ø§Ø³ Ø¨Ø±Ø§ÛŒ Ø³Ø§Ø®Øª Ø¯Ø±Ø®ØªØ§Ù† Ù…ÙˆÙ‚Øª Ø¯Ø± ÙØ±Ø¢ÛŒÙ†Ø¯ Ù…Ø­Ø§Ø³Ø¨Ù‡ FN Ø¶Ø±ÙˆØ±ÛŒ Ø§Ø³Øª. 
29       """
30       def __init__(self, name, func):
31           super().__init__()
32           self.name = name
33           self.func = func
34   
35       def compute_metric(self, metric_data: np.ndarray) -> float:
36           """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù†Ø§Ø®Ø§Ù„ØµÛŒ Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ú¯Ø±Ù‡ Ú©Ø§Ù…Ù„."""
37           try:
38               y = metric_data[:, 0] if metric_data.ndim > 1 else metric_data
39               # ÙØ±Ø¶ Ø¨Ø± Ø§ÛŒÙ† Ø§Ø³Øª Ú©Ù‡ ØªØ§Ø¨Ø¹ Ù…Ø¹ÛŒØ§Ø± Ø¨Ø§ ÛŒÚ© Ø¢Ø±Ø§ÛŒÙ‡ Ø®Ø§Ù„ÛŒ Ø¨Ø±Ø§ÛŒ y_left Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯
40               return float(self.func(np.array([]), y))
41           except Exception:
42               return 0.0
43   
44       def compute_delta(self, split, metric_data):
45           """Ù…Ø­Ø§Ø³Ø¨Ù‡ Information Gain Ø¨Ø±Ø§ÛŒ ÛŒÚ© ØªÙ‚Ø³ÛŒÙ…."""
46           try:
47               y = metric_data[:, 0] if metric_data.ndim > 1 else metric_data
48               
49               if split.dtype == bool:
50                   y_left, y_right = y[split], y[~split]
51               else:
52                   mask = np.ones(len(y), dtype=bool)
53                   mask[split] = False
54                   y_left, y_right = y[split], y[mask]
55   
56               # Ù…Ø­Ø§Ø³Ø¨Ù‡ information gain (Ú©Ø§Ù‡Ø´ Ù†Ø§Ø®Ø§Ù„ØµÛŒ)
57               parent_impurity = self.func(np.array([]), y)
58               p_left = len(y_left) / len(y) if len(y) > 0 else 0
59               p_right = len(y_right) / len(y) if len(y) > 0 else 0
60               
61               impurity_left = self.func(np.array([]), y_left) if len(y_left) > 0 else 0
62               impurity_right = self.func(np.array([]), y_right) if len(y_right) > 0 else 0
63               
64               weighted_child_impurity = (p_left * impurity_left) + (p_right * impurity_right)
65               
66               return parent_impurity - weighted_child_impurity
67           except Exception:
68               return 0.0
69   
70   # ================================================================
71   # Ú©Ù„Ø§Ø³ Û²: WeightedVotingMetric (Ø¨Ø§ Ù…ØªØ¯ evaluate Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡)
72   # Ø§ÛŒÙ† Ù…ØºØ² Ù…ØªÙÚ©Ø± Ù…Ø¯Ù„ Ø´Ù…Ø§Ø³Øª.
73   # ================================================================
74   class WeightedVotingMetric(MetricBase):
75       """ 
76       ÛŒÚ© Ù…ØªØ±ÛŒÚ© Ø³ÙØ§Ø±Ø´ÛŒ Ú©Ù‡ Ø§Ø² ØªØ±Ú©ÛŒØ¨ ÙˆØ²Ù†â€ŒØ¯Ø§Ø± Ú†Ù†Ø¯ÛŒÙ† Ù…Ø¹ÛŒØ§Ø± Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ ØªÙ‚Ø³ÛŒÙ…â€ŒÙ‡Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†Ø¯. 
77       ÙˆØ²Ù†â€ŒÙ‡Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ù¾ÙˆÛŒØ§ Ø¯Ø± Ù‡Ø± Ú¯Ø±Ù‡ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ù‡Ø± Ù…Ø¹ÛŒØ§Ø± Ø¯Ø± Ú©Ø§Ù‡Ø´ False Negatives Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯. 
78       """
79       def __init__(self, criteria, a):
80           super().__init__()
81           self.criteria = criteria  # Ù„ÛŒØ³ØªÛŒ Ø§Ø² (Ù†Ø§Ù…ØŒ ØªØ§Ø¨Ø¹) Ù…Ø¹ÛŒØ§Ø±Ù‡Ø§
82           self.a = a  # Ú©Ù„ Ø¯ÛŒØªØ§Ø³Øª ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ (X)
83           self.weights_dict = {}  # Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ Ø¨Ø±Ø§ÛŒ Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ ÙˆØ²Ù†â€ŒÙ‡Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯Ù‡ Ø¯Ø± Ù‡Ø± Ú¯Ø±Ù‡
84           self._fn_cache = {}  # Ú©Ø´ Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ù…Ø­Ø§Ø³Ø¨Ø§Øª ØªÚ©Ø±Ø§Ø±ÛŒ FN
85   
86       def estimate_fn_for_criterion(self, name, x_data, y_node):
87           """Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ù…Ø¹ÛŒØ§Ø± Ù…Ø´Ø®ØµØŒ Ø¨Ø§ Ø³Ø§Ø®ØªÙ† ÛŒÚ© Ø¯Ø±Ø®Øª Ù…ÙˆÙ‚ØªØŒ Ù…Ù‚Ø¯Ø§Ø± FN Ø±Ø§ ØªØ®Ù…ÛŒÙ† Ù…ÛŒâ€ŒØ²Ù†Ø¯."""
88           from custom_tree_classifier.models.decision_tree import CustomDecisionTreeClassifier
89           cache_key = f"{name}_{len(x_data)}_{hash(y_node.tobytes())}_{hash(x_data.tobytes())}"
90           if cache_key in self._fn_cache:
91               return self._fn_cache[cache_key]
92   
93           if x_data.shape[0] != y_node.shape[0]:
94               return np.inf # Ø¯Ø± ØµÙˆØ±Øª Ø¹Ø¯Ù… ØªØ·Ø§Ø¨Ù‚ Ø¯Ø§Ø¯Ù‡ØŒ ÛŒÚ© Ù¾Ù†Ø§Ù„ØªÛŒ Ø¨Ø²Ø±Ú¯ Ø¯Ø± Ù†Ø¸Ø± Ù…ÛŒâ€ŒÚ¯ÛŒØ±ÛŒÙ…
95   
96           try:
97               criterion_func = dict(self.criteria)[name]
98               metric_obj = SingleCriterionMetric(name, criterion_func)
99               
100              model = CustomDecisionTreeClassifier(max_depth=3, metric=metric_obj)
101              metric_data = y_node.reshape(-1, 1)
102              model.fit(x_data, y_node, metric_data)
103              
104              probas = model.predict_proba(x_data)
105              preds = (probas[:, 1] > 0.5).astype(int) if probas.shape[1] > 1 else np.zeros_like(y_node)
106              
107              fn_count = np.sum((y_node == 1) & (preds == 0))
108              self._fn_cache[cache_key] = fn_count
109              return fn_count
110          except Exception as e:
111              print(f"[ERROR] Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ FN Ø¨Ø±Ø§ÛŒ {name}: {e}")
112              return np.inf
113  
114      def update_weights_dynamic(self, x_data, y_node):
115          """ 
116          FNÙ‡Ø§ Ø±Ø§ Ø¨Ø±Ø§ÛŒ ØªÙ…Ø§Ù… Ù…Ø¹ÛŒØ§Ø±Ù‡Ø§ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ùˆ Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ ÙˆØ²Ù†â€ŒÙ‡Ø§ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ú¯Ø±Ù‡ ÙØ¹Ù„ÛŒ Ø¨Ù‡â€ŒØ±ÙˆØ² Ù…ÛŒâ€ŒÚ©Ù†Ø¯. 
117          Ø§ÛŒÙ† Ù…ØªØ¯ ØªÙˆØ³Ø· `fit` Ø§Ø² `CustomDecisionTreeClassifier` ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯. 
118          """
119          if len(x_data) < 2:
120              return self.weights_dict # Ø§Ú¯Ø± Ø¯Ø§Ø¯Ù‡ Ú©Ø§ÙÛŒ Ù†ÛŒØ³ØªØŒ Ø§Ø² ÙˆØ²Ù†â€ŒÙ‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†
121  
122          fn_values = [self.estimate_fn_for_criterion(name, x_data, y_node) for name, _ in self.criteria]
123          print(f"  FNs calculated: {dict(zip([c[0] for c in self.criteria], fn_values))}")
124  
125          # ØªØ¨Ø¯ÛŒÙ„ FN Ø¨Ù‡ ÙˆØ²Ù† (Ù…Ø¹Ú©ÙˆØ³ FN) Ùˆ Ù†Ø±Ù…Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ
126          fn_values = np.array(fn_values, dtype=float)
127          fn_values[fn_values < 1e-9] = 1e-9 # Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² ØªÙ‚Ø³ÛŒÙ… Ø¨Ø± ØµÙØ±
128  
129          weights = 1.0 / fn_values
130          total_weight = np.sum(weights)
131  
132          if total_weight > 0:
133              normalized_weights = weights / total_weight
134          else:
135              # Ø¯Ø± ØµÙˆØ±Øª Ø¨Ø±ÙˆØ² Ø®Ø·Ø§ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ù…Ø¹ÛŒØ§Ø±Ù‡Ø§ØŒ ÙˆØ²Ù† Ù…Ø³Ø§ÙˆÛŒ Ø¯Ø± Ù†Ø¸Ø± Ø¨Ú¯ÛŒØ±
136              num_criteria = len(self.criteria)
137              normalized_weights = np.full(num_criteria, 1.0 / num_criteria)
138              
139          self.weights_dict = {name: weight for (name, _), weight in zip(self.criteria, normalized_weights)}
140          print(f"  New weights set: {self.weights_dict}")
141          return self.weights_dict
142  
143      def evaluate(self, y_left, y_right, split_info=None):
144          """ 
145          ğŸ”¥ Ù…ØªØ¯ Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡ ğŸ”¥ 
146          Ø§Ù…ØªÛŒØ§Ø² ÙˆØ²Ù†ÛŒ ÛŒÚ© ØªÙ‚Ø³ÛŒÙ… Ø±Ø§ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ÙˆØ²Ù†â€ŒÙ‡Ø§ÛŒ Ø§Ø² Ù¾ÛŒØ´ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯Ù‡ØŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒâ€ŒÚ©Ù†Ø¯. 
147          Ø§ÛŒÙ† Ù…ØªØ¯ Ø¯ÛŒÚ¯Ø± Ø®ÙˆØ¯Ø´ ÙˆØ²Ù†â€ŒÙ‡Ø§ Ø±Ø§ Ø¢Ù¾Ø¯ÛŒØª Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯. 
148          """
149          if len(y_left) == 0 or len(y_right) == 0:
150              return 0.0
151  
152          # Ø§Ú¯Ø± Ø¨Ù‡ Ù‡Ø± Ø¯Ù„ÛŒÙ„ÛŒ ÙˆØ²Ù†â€ŒÙ‡Ø§ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù†Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ù†Ø¯ (Ù†Ø¨Ø§ÛŒØ¯ Ø§ØªÙØ§Ù‚ Ø¨ÛŒÙØªØ¯)ØŒ Ø§Ø² ÙˆØ²Ù† Ù…Ø³Ø§ÙˆÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†
153          if not self.weights_dict:
154              print("[WARNING] `evaluate` ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ Ø´Ø¯ Ø¯Ø± Ø­Ø§Ù„ÛŒ Ú©Ù‡ ÙˆØ²Ù†â€ŒÙ‡Ø§ ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡ Ø¨ÙˆØ¯Ù†Ø¯. Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ÙˆØ²Ù† Ù…Ø³Ø§ÙˆÛŒ.")
155              self.weights_dict = {name: 1.0 / len(self.criteria) for name, _ in self.criteria}
156          
157          # Û±. Ù…Ø­Ø§Ø³Ø¨Ù‡ information gain Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù…Ø¹ÛŒØ§Ø±
158          scores = []
159          y_parent = np.concatenate((y_left, y_right))
160          for name, func in self.criteria:
161              try:
162                  parent_impurity = func(np.array([]), y_parent)
163                  p_left = len(y_left) / len(y_parent)
164                  child_impurity = (p_left * func(np.array([]), y_left)) + \
165                                   ((1 - p_left) * func(np.array([]), y_right))
166                  gain = parent_impurity - child_impurity
167                  scores.append(gain)
168              except Exception:
169                  scores.append(0.0)
170  
171          # Û². Ø®ÙˆØ§Ù†Ø¯Ù† ÙˆØ²Ù†â€ŒÙ‡Ø§ Ø§Ø² Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ
172          weights = np.array([self.weights_dict.get(name, 0.0) for name, _ in self.criteria])
173  
174          # Û³. Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù…ØªÛŒØ§Ø² Ù†Ù‡Ø§ÛŒÛŒ (Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† ÙˆØ²Ù†ÛŒ Ø§Ø² information gain Ù‡Ø§)
175          if weights.sum() > 0:
176              weighted_score = np.dot(scores, weights)
177          else:
178              # Ø§ÛŒÙ† Ø­Ø§Ù„Øª ÙÙ‚Ø· Ø¯Ø± ØµÙˆØ±Øª Ø¨Ø±ÙˆØ² Ø®Ø·Ø§ÛŒ Ø¬Ø¯ÛŒ Ø±Ø® Ù…ÛŒâ€ŒØ¯Ù‡Ø¯
179              weighted_score = np.mean(scores) if scores else 0.0
180              
181          return float(weighted_score)
182  
183      def compute_metric(self, metric_data: np.ndarray) -> float:
184          """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù†Ø§Ø®Ø§Ù„ØµÛŒ Ú©Ù„ÛŒ ÛŒÚ© Ú¯Ø±Ù‡ (Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø§Ø² Ø¯ÛŒØ¯ Ù‡Ù…Ù‡ Ù…Ø¹ÛŒØ§Ø±Ù‡Ø§)."""
185          if len(metric_data) == 0:
186              return 0.0
187          y = metric_data[:, 0] if metric_data.ndim > 1 else metric_data
188          total_impurity = sum(func(np.array([]), y) for _, func in self.criteria)
189          return total_impurity / len(self.criteria) if self.criteria else 0.0
190  
191      def compute_delta(self, split: np.ndarray, metric_data: np.ndarray) -> float:
192          """Ø§ÛŒÙ† Ù…ØªØ¯ Ø¨Ù‡ Ø¯Ø±Ø³ØªÛŒ `evaluate` Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ gain ØµØ¯Ø§ Ù…ÛŒâ€ŒØ²Ù†Ø¯."""
193          y = metric_data[:, 0] if metric_data.ndim > 1 else metric_data
194          if split.dtype == bool:
195              y_left, y_right = y[split], y[~split]
196          else:
197              mask = np.ones(len(y), dtype=bool)
198              mask[split] = False
199              y_left, y_right = y[split], y[mask]
200              
201          return self.evaluate(y_left, y_right)
202  
203  # ================================================================
204  # Ú©Ù„Ø§Ø³ Û³: CriterionWrapper (Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ±)
205  # ================================================================
206  class CriterionWrapper:
207      # Ø§ÛŒÙ† Ú©Ù„Ø§Ø³ Ø§Ú¯Ø± Ø¯Ø± Ø¬Ø§ÛŒ Ø¯ÛŒÚ¯Ø±ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯ØŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø­Ø°Ù Ø´ÙˆØ¯.
208      # Ø¯Ø± Ø§ÛŒÙ† Ù…Ø¹Ù…Ø§Ø±ÛŒ Ø¬Ø¯ÛŒØ¯ØŒ Ù†Ù‚Ø´ Ù…Ø³ØªÙ‚ÛŒÙ…ÛŒ Ù†Ø¯Ø§Ø±Ø¯.
209      def __init__(self, name, func):
210          self.name = name
211          self.func = func
212          
213      def calculate_score(self, y_left, y_right):
214          try:
215              return self.func(y_left, y_right)
216          except Exception:
217              return 0.0
218  
219  # ================================================================
220  # Ú©Ù„Ø§Ø³ Û´: WeightedDecisionTreeModel (Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ±)
221  # Ø§ÛŒÙ† Ú©Ù„Ø§Ø³ Ø§Ø±Ú©Ø³ØªØ±Ø§ØªÙˆØ± Ø§ØµÙ„ÛŒ Ø§Ø³Øª Ùˆ Ù†ÛŒØ§Ø²ÛŒ Ø¨Ù‡ ØªØºÛŒÛŒØ± Ù†Ø¯Ø§Ø±Ø¯.
222  # ================================================================
223  class WeightedDecisionTreeModel:
224  # Ø¯Ø± ÙØ§ÛŒÙ„ src/model/weighted_decision_tree.py
225  # Ø¯Ø± Ú©Ù„Ø§Ø³ WeightedDecisionTreeModel
226  
227      def __init__(self, criteria_funcs_weights=None, positive_label=1, max_depth=5, a=None):
228          if criteria_funcs_weights is None:
229              criteria_funcs_weights = [
230                  #("gini", gini_criterion), ("gain_ratio", gain_ratio_criterion),
231                  ("twoing", twoing_criterion), ("normalized_gain", normalized_gain_criterion),
232                  ("multi_class_hellinger", multi_class_hellinger), ("marshall", marsh_criterion),
233                  ("g_statistic", g_statistic_criterion), ("dkm", dkm_criterion),
234                  ("chi_squared", chi_squared_criterion), ("bhattacharyya", bhattacharyya_criterion),
235                  ("kolmogorov_smirnov", kolmogorov_smirnov_criterion),
236              ]
237          self.criteria = criteria_funcs_weights
238          self.positive_label = positive_label
239          
240          # ğŸ”¥ Ø®Ø· Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡ Ùˆ Ø¨Ø³ÛŒØ§Ø± Ù…Ù‡Ù… Ú©Ù‡ ÙØ±Ø§Ù…ÙˆØ´ Ø´Ø¯Ù‡ Ø¨ÙˆØ¯
241          self.max_depth = max_depth
242          
243          if a is None:
244              raise ValueError("a Ø¨Ø§ÛŒØ¯ Ø¯Ø§Ø¯Ù‡ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ú©Ø§Ù…Ù„ Ø±Ø§ Ø¨Ù‡ Ù…Ø¯Ù„ Ø¨Ø¯Ù‡ÛŒØ¯.")
245          
246          self.a = np.array(a.values) if hasattr(a, "values") else np.array(a)
247          
248          self.metric = WeightedVotingMetric(self.criteria, self.a)
249          self.model = None
250  
251  
252      def compute_initial_weights(self, X, y):
253          from custom_tree_classifier.models.decision_tree import CustomDecisionTreeClassifier
254  
255          """ÙˆØ²Ù†â€ŒÙ‡Ø§ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ú¯Ø±Ù‡ Ø±ÛŒØ´Ù‡ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒâ€ŒÚ©Ù†Ø¯."""
256          print("[INIT] Ø´Ø±ÙˆØ¹ Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙˆØ²Ù†â€ŒÙ‡Ø§ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ Ú¯Ø±Ù‡ Ø±ÛŒØ´Ù‡...")
257          # Ø§Ø² Ù‡Ù…Ø§Ù† Ù…Ù†Ø·Ù‚ `update_weights_dynamic` Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
258          initial_weights = self.metric.update_weights_dynamic(X, y)
259          self.metric.weights_dict = initial_weights
260          print(f"ÙˆØ²Ù†â€ŒÙ‡Ø§ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯: {initial_weights}")
261  
262      # Ø¯Ø± Ú©Ù„Ø§Ø³ WeightedDecisionTreeModel
263      
264  # Ø¯Ø± ÙØ§ÛŒÙ„ src/model/weighted_decision_tree.py
265  
266      def fit(self, x, y):
267          """ 
268          Ù…Ø¯Ù„ Ø±Ø§ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ Ø¢Ù…ÙˆØ²Ø´ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯. 
269          """
270          # ğŸ”¥ Ø§ØµÙ„Ø§Ø­ÛŒÙ‡ Û±: Ø§ÛŒÙ…Ù¾ÙˆØ±Øª Ù…Ø­Ù„ÛŒ Ø¨Ø±Ø§ÛŒ Ø´Ú©Ø³ØªÙ† Ú†Ø±Ø®Ù‡ ÙˆØ§Ø¨Ø³ØªÚ¯ÛŒ
271          from custom_tree_classifier.models.decision_tree import CustomDecisionTreeClassifier
272  
273          # ğŸ”¥ Ø§ØµÙ„Ø§Ø­ÛŒÙ‡ Û² (Ø¨Ø³ÛŒØ§Ø± Ù…Ù‡Ù…): Ø³Ø§Ø®Øª Ù…Ø¯Ù„ Ø¯Ø± Ù„Ø­Ø¸Ù‡ Ù†ÛŒØ§Ø²
274          # Ø§Ú¯Ø± Ù…Ø¯Ù„ Ø³Ø§Ø®ØªÙ‡ Ù†Ø´Ø¯Ù‡ (None Ø§Ø³Øª)ØŒ Ø¢Ù† Ø±Ø§ Ø¨Ø³Ø§Ø²
275          if self.model is None:
276              # Ø¯Ø± Ù…ØªØ¯ __init__ Ú©Ù„Ø§Ø³ WeightedDecisionTreeModel
277              #self.model = CustomDecisionTreeClassifier() # Ø¯Ø±Ø³Øª: ÛŒÚ© Ù†Ù…ÙˆÙ†Ù‡ Ø§Ø² Ú©Ù„Ø§Ø³ Ø³Ø§Ø®ØªÙ‡â€ŒØ§ÛŒØ¯
278  
279              self.model = CustomDecisionTreeClassifier(
280                  max_depth=self.max_depth,
281                  metric=self.metric
282              )
283          
284          # Ù…Ø±Ø­Ù„Ù‡ Û±: Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ (Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ±)
285          X_fit = x.values if hasattr(x, "values") else x
286          y_fit = y.values if hasattr(y, "values") else y
287          
288          print(f"Ø´Ø±ÙˆØ¹ Ø¢Ù…ÙˆØ²Ø´ Ù…Ø¯Ù„ - Ø´Ú©Ù„ Ø¯Ø§Ø¯Ù‡: x={X_fit.shape}, y={y_fit.shape}")
289          
290          # Ù…Ø±Ø­Ù„Ù‡ Û²: Ù…Ø­Ø§Ø³Ø¨Ù‡ Ùˆ ØªÙ†Ø¸ÛŒÙ… ÙˆØ²Ù†â€ŒÙ‡Ø§ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ (Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ±)
291          self.compute_initial_weights(X_fit, y_fit)
292          
293          # Ù…Ø±Ø­Ù„Ù‡ Û³: Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡ Ù…ØªØ±ÛŒÚ© (Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ±)
294          metric_data = y_fit.reshape(-1, 1)
295  
296   
297  
298          import custom_tree_classifier.models.decision_tree as dt
299  
300          print("Path of the loaded module:", dt.__file__)
301  
302  
303          # Ù…Ø±Ø­Ù„Ù‡ Û´: ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ fit Ø§ØµÙ„ÛŒ Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ (Ø­Ø§Ù„Ø§ Ø¨Ø¯ÙˆÙ† Ø®Ø·Ø§ Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯)
304          self.model.fit(X_fit, y_fit, metric_data)
305  
306  
307  
308          print("Ø¢Ù…ÙˆØ²Ø´ ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯!")
309  
310  
311      def predict(self, x):
312          X_pred = x.values if hasattr(x, "values") else x
313          probas = self.model.predict_proba(X_pred)
314          if probas.shape[1] > 1:
315              return np.argmax(probas, axis=1)
316          else:
317              return (probas[:, 0] > 0.5).astype(int)
318  
319      def predict_proba(self, x):
320          X_pred = x.values if hasattr(x, "values") else x
321          return self.model.predict_proba(X_pred)
322  
323  # ================================================================
324  # Ø¨Ø®Ø´ Ø§Ø¬Ø±Ø§ÛŒÛŒ (Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ±)
325  # ================================================================
326  if __name__ == "__main__":
327      from sklearn.datasets import make_classification
328      
329      # Ø³Ø§Ø®Øª Ø¯Ø§Ø¯Ù‡ Ù†Ù…ÙˆÙ†Ù‡
330      X_data, y_data = make_classification(n_samples=100, n_features=10, n_informative=5, n_redundant=0, n_classes=2, random_state=42)
331      
332      # Ø³Ø§Ø®Øª Ùˆ Ø¢Ù…ÙˆØ²Ø´ Ù…Ø¯Ù„
333      model = WeightedDecisionTreeModel(a=X_data, max_depth=5)
334      model.fit(X_data, y_data)
335      
336      # Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ
337      predictions = model.predict(X_data)
338      probabilities = model.predict_proba(X_data)
339      
340      print("\n--- Ù†ØªØ§ÛŒØ¬ Ù†Ù‡Ø§ÛŒÛŒ ---")
341      print(f"ØªØ¹Ø¯Ø§Ø¯ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒâ€ŒÙ‡Ø§: {len(predictions)}")
342      print(f"Ù†Ù…ÙˆÙ†Ù‡ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒâ€ŒÙ‡Ø§: {predictions[:10]}")
343      print(f"Ù†Ù…ÙˆÙ†Ù‡ Ø§Ø­ØªÙ…Ø§Ù„Ø§Øª: \n{probabilities[:5]}")
344      print("\nÙ…Ø¯Ù„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø¬Ø±Ø§ Ø´Ø¯!")
345  

